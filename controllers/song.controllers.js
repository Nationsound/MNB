const Song = require('../models/songSchema');
const cloudinary = require('../utils/cloudinary');
const streamifier = require('streamifier');
const NodeID3 = require('node-id3');

// Helper: Upload buffer to Cloudinary
function uploadBufferToCloudinary(buffer, opts = {}) {
  const defaultOpts = { folder: process.env.CLOUDINARY_FOLDER || 'mnb', resource_type: 'auto' };
  const options = { ...defaultOpts, ...opts };

  return new Promise((resolve, reject) => {
    const stream = cloudinary.uploader.upload_stream(options, (err, res) =>
      err ? reject(err) : resolve(res)
    );
    streamifier.createReadStream(buffer).pipe(stream);
  });
}

// ✅ Create Song
const createSong = async (req, res, next) => {
  try {
    const { title, artist, albumName, genre, description, releaseDate } = req.body;
    if (!title || !artist || !genre) {
      return res.status(400).json({ message: 'Title, artist, and genre are required' });
    }

    const audioFile = req.files?.audio?.[0];
    const imageFile = req.files?.coverImage?.[0];
    if (!audioFile) {
      return res.status(400).json({ message: 'Audio file is required' });
    }

    // Prepare ID3 tags
    const tags = { title, artist, album: albumName || '', genre };
    if (imageFile) {
      tags.APIC = {
        mime: imageFile.mimetype,
        type: { id: 3, name: 'front cover' },
        description: 'Cover',
        imageBuffer: imageFile.buffer,
      };
    }

    // Inject ID3 tags
    let audioBuffer = NodeID3.update(tags, audioFile.buffer);

    // Upload audio
    const audioUp = await uploadBufferToCloudinary(audioBuffer, { resource_type: 'auto' });

    // Upload cover image if present
    let imageUp;
    if (imageFile) {
      imageUp = await uploadBufferToCloudinary(imageFile.buffer, { resource_type: 'image' });
    }

    // Save to DB — slug will be auto-generated by schema
    const newSong = await Song.create({
      title,
      artist,
      albumName,
      genre,
      description,
      audioUrl: audioUp.secure_url,
      audioPublicId: audioUp.public_id,
      ...(imageUp && {
        coverImageUrl: imageUp.secure_url,
        coverImagePublicId: imageUp.public_id
      }),
      releaseDate: releaseDate || Date.now(),
    });

    res.status(201).json(newSong);
  } catch (error) {
    console.error('Create song error:', error);
    next(error);
  }
};

// ✅ Get All Songs (Paginated)
const getAllSongs = async (req, res, next) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;

    const total = await Song.countDocuments();
    const songs = await Song.find()
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit);

    res.json({
      total,
      page,
      totalPages: Math.ceil(total / limit),
      songs,
    });
  } catch (error) {
    console.error('Get all songs error:', error);
    next(error);
  }
};

// ✅ Get Song by Slug
const getSongBySlug = async (req, res) => {
  try {
    const song = await Song.findOne({ slug: req.params.slug });
    if (!song) return res.status(404).json({ message: 'Song not found' });
    res.json(song);
  } catch (error) {
    console.error('Error fetching song by slug:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// ✅ Update Song
const updateSong = async (req, res) => {
  try {
    const song = await Song.findOne({ slug: req.params.slug });
    if (!song) return res.status(404).json({ message: 'Song not found' });

    const { title, artist, albumName, genre, description, releaseDate } = req.body;
    const update = {
      title: title ?? song.title,
      artist: artist ?? song.artist,
      albumName: albumName ?? song.albumName,
      genre: genre ?? song.genre,
      description: description ?? song.description,
      releaseDate: releaseDate ?? song.releaseDate,
    };

    const audioFile = req.files?.audio?.[0];
    const imageFile = req.files?.coverImage?.[0];

    // Replace audio if provided
    if (audioFile) {
      const tags = {
        title: update.title,
        artist: update.artist,
        album: update.albumName || '',
        genre: update.genre,
      };
      if (imageFile) {
        tags.APIC = {
          mime: imageFile.mimetype,
          type: { id: 3, name: 'front cover' },
          description: 'Cover',
          imageBuffer: imageFile.buffer,
        };
      }

      let audioBuffer = NodeID3.update(tags, audioFile.buffer);
      const audioUp = await uploadBufferToCloudinary(audioBuffer, { resource_type: 'auto' });
      update.audioUrl = audioUp.secure_url;
      update.audioPublicId = audioUp.public_id;

      if (song.audioPublicId) {
        try {
          await cloudinary.uploader.destroy(song.audioPublicId, { resource_type: 'video' });
        } catch (e) {
          console.warn('Could not delete old audio:', e.message);
        }
      }
    }

    // Replace cover image if provided
    if (imageFile) {
      const imageUp = await uploadBufferToCloudinary(imageFile.buffer, { resource_type: 'image' });
      update.coverImageUrl = imageUp.secure_url;
      update.coverImagePublicId = imageUp.public_id;

      if (song.coverImagePublicId) {
        try {
          await cloudinary.uploader.destroy(song.coverImagePublicId, { resource_type: 'image' });
        } catch (e) {
          console.warn('Could not delete old cover image:', e.message);
        }
      }
    }

    const updatedSong = await Song.findByIdAndUpdate(song._id, update, { new: true });
    res.json(updatedSong);
  } catch (error) {
    console.error('Error updating song:', error.message);
    res.status(500).json({ message: 'Server error' });
  }
};

// ✅ Delete Song
const deleteSong = async (req, res) => {
  try {
    const song = await Song.findOne({ slug: req.params.slug });
    if (!song) return res.status(404).json({ message: 'Song not found' });

    if (song.audioPublicId) {
      try {
        await cloudinary.uploader.destroy(song.audioPublicId, { resource_type: 'video' });
      } catch (e) {
        console.warn('Could not delete song audio:', e.message);
      }
    }
    if (song.coverImagePublicId) {
      try {
        await cloudinary.uploader.destroy(song.coverImagePublicId, { resource_type: 'image' });
      } catch (e) {
        console.warn('Could not delete song cover image:', e.message);
      }
    }

    await Song.findByIdAndDelete(song._id);
    res.json({ message: 'Song deleted successfully' });
  } catch (error) {
    console.error('Error deleting song:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

module.exports = {
  createSong,
  getAllSongs,
  getSongBySlug,
  updateSong,
  deleteSong,
};
